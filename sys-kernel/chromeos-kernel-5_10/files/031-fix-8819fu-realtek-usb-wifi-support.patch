Index: linux/drivers/net/wireless/rockchip_wlan/Kconfig
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/Kconfig
+++ linux/drivers/net/wireless/rockchip_wlan/Kconfig
@@ -40,5 +40,6 @@ source "drivers/net/wireless/rockchip_wl
 source "drivers/net/wireless/rockchip_wlan/infineon/Kconfig"
 source "drivers/net/wireless/rockchip_wlan/rtl8852be/Kconfig"
 source "drivers/net/wireless/rockchip_wlan/rtl8852bu/Kconfig"
+source "drivers/net/wireless/rockchip_wlan/rtl8188fu/Kconfig"
 
 endif # WL_ROCKCHIP
Index: linux/drivers/net/wireless/rockchip_wlan/Makefile
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/Makefile
+++ linux/drivers/net/wireless/rockchip_wlan/Makefile
@@ -4,4 +4,5 @@ obj-$(CONFIG_CYW_BCMDHD)	+= cywdhd/
 obj-$(CONFIG_INFINEON_DHD)	+= infineon/
 
 obj-$(CONFIG_RTL8852BE)		+= rtl8852be/
-obj-$(CONFIG_RTL8852BU)		+= rtl8852bu/
\ No newline at end of file
+obj-$(CONFIG_RTL8852BU)		+= rtl8852bu/
+obj-$(CONFIG_RTL8188FU) += rtl8188fu/
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/Makefile
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/Makefile
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/Makefile
@@ -21,8 +21,7 @@ ifeq ($(GCC_VER_49),1)
 EXTRA_CFLAGS += -Wno-date-time	# Fix compile error && warning on gcc 4.9 and later
 endif
 
-EXTRA_CFLAGS += -I$(src)/include
-
+EXTRA_CFLAGS += -I$(srctree)/$(src)/include
 EXTRA_LDFLAGS += --strip-debug
 
 CONFIG_AUTOCFG_CP = n
@@ -243,10 +242,10 @@ _HAL_INTFS_FILES :=	hal/hal_intf.o \
 			hal/led/hal_$(HCI_NAME)_led.o
 
 
-EXTRA_CFLAGS += -I$(src)/platform
+EXTRA_CFLAGS += -I$(srctree)/$(src)/platform
 _PLATFORM_FILES := platform/platform_ops.o
 
-EXTRA_CFLAGS += -I$(src)/hal/btc
+EXTRA_CFLAGS += -I$(srctree)/$(src)/hal/btc
 
 ########### HAL_RTL8188E #################################
 ifeq ($(CONFIG_RTL8188E), y)
@@ -460,7 +459,7 @@ endif
 EXTRA_CFLAGS += -DCONFIG_RTL8821A
 
 _HAL_INTFS_FILES +=	hal/rtl8812a/hal8821a_fw.o
-		
+
 endif
 
 ifeq ($(CONFIG_BT_COEXIST), y)
@@ -917,7 +916,7 @@ _HAL_INTFS_FILES +=	\
 			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_led.o \
 			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_xmit.o \
 			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_SUB_NAME)_recv.o
-			
+
 ifeq ($(CONFIG_PCI_HCI), y)
 _HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
 else
@@ -2096,7 +2095,7 @@ ARCH := arm
 CROSS_COMPILE := /home/android_sdk/Telechips/v13.05_r1-tcc-android-4.2.2_tcc893x-evm_build/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
 KSRC := /home/android_sdk/Telechips/v13.05_r1-tcc-android-4.2.2_tcc893x-evm_build/kernel
 MODULE_NAME := wlan
-endif 
+endif
 
 ifeq ($(CONFIG_PLATFORM_RTL8197D), y)
 EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN -DCONFIG_PLATFORM_RTL8197D
@@ -2202,21 +2201,21 @@ endif
 ifneq ($(KERNELRELEASE),)
 
 ########### this part for *.mk ############################
-include $(src)/hal/phydm/phydm.mk
+include $(srctree)/$(src)/hal/phydm/phydm.mk
 
 ########### HAL_RTL8822B #################################
 ifeq ($(CONFIG_RTL8822B), y)
-include $(src)/rtl8822b.mk
+include $(srctree)/$(src)/rtl8822b.mk
 endif
 
 ########### HAL_RTL8821C #################################
 ifeq ($(CONFIG_RTL8821C), y)
-include $(src)/rtl8821c.mk
+include $(srctree)/$(src)/../rtl8821cs/rtl8821c.mk
 endif
 
 ########### HAL_RTL8822C #################################
 ifeq ($(CONFIG_RTL8822C), y)
-include $(src)/rtl8822c.mk
+include $(srctree)/$(src)/rtl8822c.mk
 endif
 
 rtk_core :=	core/rtw_cmd.o \
@@ -2253,7 +2252,7 @@ rtk_core :=	core/rtw_cmd.o \
 		core/rtw_odm.o \
 		core/rtw_rm.o \
 		core/rtw_rm_fsm.o \
-		core/efuse/rtw_efuse.o 
+		core/efuse/rtw_efuse.o
 
 ifeq ($(CONFIG_SDIO_HCI), y)
 rtk_core += core/rtw_sdio.o
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_security.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_security.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_security.c
@@ -2134,7 +2134,7 @@ BIP_exit:
 #ifndef PLATFORM_FREEBSD
 #if defined(CONFIG_TDLS)
 /* compress 512-bits */
-static int sha256_compress(struct sha256_state *md, unsigned char *buf)
+static int sha256_compress(struct sha256_state_ctx *md, unsigned char *buf)
 {
 	u32 S[8], W[64], t0, t1;
 	u32 t;
@@ -2182,7 +2182,7 @@ static int sha256_compress(struct sha256
 }
 
 /* Initialize the hash state */
-static void sha256_init(struct sha256_state *md)
+static void sha256_init(struct sha256_state_ctx *md)
 {
 	md->curlen = 0;
 	md->length = 0;
@@ -2203,7 +2203,7 @@ static void sha256_init(struct sha256_st
    @param inlen  The length of the data (octets)
    @return CRYPT_OK if successful
 */
-static int sha256_process(struct sha256_state *md, unsigned char *in,
+static int sha256_process(struct sha256_state_ctx *md, unsigned char *in,
 			  unsigned long inlen)
 {
 	unsigned long n;
@@ -2244,7 +2244,7 @@ static int sha256_process(struct sha256_
    @param out [out] The destination of the hash (32 bytes)
    @return CRYPT_OK if successful
 */
-static int sha256_done(struct sha256_state *md, unsigned char *out)
+static int sha256_done(struct sha256_state_ctx *md, unsigned char *out)
 {
 	int i;
 
@@ -2294,7 +2294,7 @@ static int sha256_done(struct sha256_sta
 static int sha256_vector(size_t num_elem, u8 *addr[], size_t *len,
 			 u8 *mac)
 {
-	struct sha256_state ctx;
+	struct sha256_state_ctx ctx;
 	size_t i;
 
 	sha256_init(&ctx);
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halphyrf_ce.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halphyrf_ce.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halphyrf_ce.c
@@ -24,8 +24,8 @@
  *
  *****************************************************************************/
 
-#include "mp_precomp.h"
-#include "phydm_precomp.h"
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
 
 #define CALCULATE_SWINGTALBE_OFFSET(_offset, _direction, _size, _delta_thermal)\
 	do {                                                                   \
@@ -880,7 +880,7 @@ odm_txpowertracking_new_callback_thermal
 		cali_info->txpowertrack_control,  tssi->thermal[RF_PATH_A], tssi->thermal[RF_PATH_B]);
 
 	thermal_value[RF_PATH_A] = (u8)odm_get_rf_reg(dm, RF_PATH_A, c.thermal_reg_addr, 0xfc00);	/* 0x42: RF Reg[15:10] 88E */
-	thermal_value[RF_PATH_B] = (u8)odm_get_rf_reg(dm, RF_PATH_B, c.thermal_reg_addr, 0xfc00);		
+	thermal_value[RF_PATH_B] = (u8)odm_get_rf_reg(dm, RF_PATH_B, c.thermal_reg_addr, 0xfc00);
 
 	for (i = 0; i < c.rf_path_count; i++) {
 		thermal_value_temp[i] = (s8)thermal_value[i] + phydm_get_thermal_offset(dm);
@@ -969,14 +969,14 @@ odm_txpowertracking_new_callback_thermal
 
 		cali_info->delta_power_index_last[i] = cali_info->delta_power_index[i];	/*recording poer index offset*/
 		delta[i] = thermal_value[i] > tssi->thermal[i] ? (thermal_value[i] - tssi->thermal[i]) : (tssi->thermal[i] - thermal_value[i]);
-				
+
 		if (delta[i] >= TXPWR_TRACK_TABLE_SIZE)
 			delta[i] = TXPWR_TRACK_TABLE_SIZE - 1;
 
 		if (thermal_value[i] > tssi->thermal[i]) {
 			RF_DBG(dm, DBG_RF_TX_PWR_TRACK,
 				"delta_swing_table_idx_tup[%d]=%d Path=%d\n", delta[i], delta_swing_table_idx_tup[delta[i]], i);
-				
+
 			cali_info->delta_power_index[i] = delta_swing_table_idx_tup[delta[i]];
 			cali_info->absolute_ofdm_swing_idx[i] =  delta_swing_table_idx_tup[delta[i]];	    /*Record delta swing for mix mode power tracking*/
 			RF_DBG(dm, DBG_RF_TX_PWR_TRACK,
@@ -991,7 +991,7 @@ odm_txpowertracking_new_callback_thermal
 		}
 	}
 
-	for (p = RF_PATH_A; p < c.rf_path_count; p++) {	
+	for (p = RF_PATH_A; p < c.rf_path_count; p++) {
 		if (cali_info->delta_power_index[p] == cali_info->delta_power_index_last[p])	     /*If Thermal value changes but lookup table value still the same*/
 			cali_info->power_index_offset[p] = 0;
 		else
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halphyrf_ce.h
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halphyrf_ce.h
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halphyrf_ce.h
@@ -27,7 +27,7 @@
 #ifndef __HALPHYRF_H__
 #define __HALPHYRF_H__
 
-#include "halrf/halrf_kfree.h"
+#include "halrf_kfree.h"
 #if (RTL8814A_SUPPORT == 1)
 #include "halrf/rtl8814a/halrf_iqk_8814a.h"
 #endif
@@ -48,11 +48,11 @@
 #endif
 
 #if (RTL8814B_SUPPORT == 1)
-	#include "halrf/rtl8814b/halrf_iqk_8814b.h"	
+	#include "halrf/rtl8814b/halrf_iqk_8814b.h"
 	#include "halrf/rtl8814b/halrf_dpk_8814b.h"
 #endif
 
-#include "halrf/halrf_powertracking_ce.h"
+#include "halrf_powertracking_ce.h"
 
 enum spur_cal_method {
 	PLL_RESET,
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf.c
@@ -29,8 +29,8 @@
  * ************************************************************
  */
 
-#include "mp_precomp.h"
-#include "phydm_precomp.h"
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
 
 #if (RTL8822B_SUPPORT == 1 || RTL8821C_SUPPORT == 1 ||\
 	RTL8195B_SUPPORT == 1 || RTL8198F_SUPPORT == 1 ||\
@@ -1327,7 +1327,7 @@ halrf_iqk_init(
 void halrf_rf_k_connect_trigger(void *dm_void, boolean is_recovery,
 				enum halrf_k_segment_time seg_time)
 {
-	struct dm_struct *dm = (struct dm_struct *)dm_void;	
+	struct dm_struct *dm = (struct dm_struct *)dm_void;
 	struct dm_dpk_info *dpk_info = &dm->dpk_info;
 	struct _hal_rf_ *rf = &dm->rf_table;
 
@@ -2051,7 +2051,7 @@ void halrf_set_dpkbychannel(void *dm_voi
 	struct dm_dpk_info *dpk_info = &dm->dpk_info;
 	struct dm_iqk_info *iqk_info = &dm->IQK_info;
 
-	
+
 	switch (dm->support_ic_type) {
 #if (RTL8814B_SUPPORT == 1)
 		case ODM_RTL8814B:
@@ -2083,7 +2083,7 @@ void halrf_set_dpkenable(void *dm_void,
 	struct dm_dpk_info *dpk_info = &dm->dpk_info;
 	struct dm_iqk_info *iqk_info = &dm->IQK_info;
 
-	
+
 	switch (dm->support_ic_type) {
 #if (RTL8814B_SUPPORT == 1)
 		case ODM_RTL8814B:
@@ -2098,8 +2098,8 @@ void halrf_set_dpkenable(void *dm_void,
 		break;
 #endif
 #endif
-		
-	
+
+
 		default:
 		break;
 	}
@@ -2112,7 +2112,7 @@ boolean halrf_get_dpkbychannel(void *dm_
 	struct dm_dpk_info *dpk_info = &dm->dpk_info;
 	struct dm_iqk_info *iqk_info = &dm->IQK_info;
 	boolean is_dpk_by_channel = true;
-	
+
 	switch (dm->support_ic_type) {
 #if (RTL8814B_SUPPORT == 1)
 		case ODM_RTL8814B:
@@ -2144,7 +2144,7 @@ boolean halrf_get_dpkenable(void *dm_voi
 	struct dm_iqk_info *iqk_info = &dm->IQK_info;
 	boolean is_dpk_enable = true;
 
-	
+
 	switch (dm->support_ic_type) {
 #if (RTL8814B_SUPPORT == 1)
 		case ODM_RTL8814B:
@@ -2390,13 +2390,13 @@ void halrf_dpk_track(void *dm_void)
 #if (RTL8814B_SUPPORT == 1)
 	case ODM_RTL8814B:
 		dpk_track_8814b(dm);
-		break;		
+		break;
 #endif
 
 #if (RTL8822C_SUPPORT == 1)
 	case ODM_RTL8822C:
 		dpk_track_8822c(dm);
-		break;		
+		break;
 #endif
 
 #if (RTL8195B_SUPPORT == 1)
@@ -2422,13 +2422,13 @@ void halrf_dpk_track(void *dm_void)
 #if (RTL8198F_SUPPORT == 1)
 	case ODM_RTL8198F:
 		dpk_track_8198f(dm);
-		break;		
+		break;
 #endif
 
 #if (RTL8812F_SUPPORT == 1)
 	case ODM_RTL8812F:
 		dpk_track_8812f(dm);
-		break;		
+		break;
 #endif
 
 #endif
@@ -2482,14 +2482,14 @@ void halrf_dpk_reload(void *dm_void)
 	case ODM_RTL8198F:
 		if (dpk_info->dpk_path_ok > 0)
 			dpk_reload_8198f(dm);
-		break;		
+		break;
 #endif
 
 #if (RTL8814B_SUPPORT == 1)
 	case ODM_RTL8814B:
 		if (dpk_info->dpk_path_ok > 0)
 			dpk_reload_8814b(dm);
-		break;		
+		break;
 #endif
 
 
@@ -2575,7 +2575,7 @@ void halrf_txgapk_trigger(void *dm_void)
 void halrf_tssi_get_efuse(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
-	
+
 #if (RTL8822C_SUPPORT == 1)
 	if (dm->support_ic_type & ODM_RTL8822C) {
 		/*halrf_tssi_get_efuse_8822c(dm);*/
@@ -2671,11 +2671,11 @@ void halrf_thermal_cck(void *dm_void)
 void halrf_tssi_set_de(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
-	
+
 #if (RTL8814B_SUPPORT == 1)
 	if (dm->support_ic_type & ODM_RTL8814B)
 		halrf_tssi_set_de_8814b(dm);
-#endif	
+#endif
 }
 
 void halrf_tssi_dck(void *dm_void, u8 direct_do)
@@ -2685,7 +2685,7 @@ void halrf_tssi_dck(void *dm_void, u8 di
 
 void halrf_calculate_tssi_codeword(void *dm_void)
 {
-	
+
 }
 
 void halrf_set_tssi_codeword(void *dm_void)
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf.h
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf.h
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf.h
@@ -30,7 +30,7 @@
 /*@============================================================*/
 /*@include files*/
 /*@============================================================*/
-#include "halrf/halrf_psd.h"
+#include "halrf_psd.h"
 #if (RTL8822B_SUPPORT == 1)
 #include "halrf/rtl8822b/halrf_rfk_init_8822b.h"
 #endif
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_debug.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_debug.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_debug.c
@@ -29,8 +29,8 @@
  * ************************************************************
  */
 
-#include "mp_precomp.h"
-#include "phydm_precomp.h"
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
 
 void halrf_basic_profile(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 {
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_kfree.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_kfree.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_kfree.c
@@ -27,8 +27,8 @@
 /*@============================================================*/
 /*@include files*/
 /*@============================================================*/
-#include "mp_precomp.h"
-#include "phydm_precomp.h"
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
 
 /*@<YuChen, 150720> Add for KFree Feature Requested by RF David.*/
 /*@This is a phydm API*/
@@ -967,7 +967,7 @@ void phydm_get_set_thermal_trim_offset_8
 	if (power_trim_info->flag & KFREE_FLAG_THERMAL_K_ON)
 		RF_DBG(dm, DBG_RF_MP, "[kfree] 8822c thermalA:%d thermalB:%d\n",
 			thermal[RF_PATH_A],
-			thermal[RF_PATH_B]);	
+			thermal[RF_PATH_B]);
 }
 
 void phydm_set_power_trim_offset_8822c(void *dm_void)
@@ -1441,7 +1441,7 @@ void phydm_config_new_kfree(void *dm_voi
 			cali_info->reg_rf_kfree_enable == 0) {
 		RF_DBG(dm, DBG_RF_MP,
 		       "[kfree] %s: reg_rf_kfree_enable == true\n", __func__);
-	
+
 		phydm_do_new_kfree(dm);
 	}
 }
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_powertracking.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_powertracking.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_powertracking.c
@@ -28,8 +28,8 @@
  * include files
  * ************************************************************
  */
-#include "mp_precomp.h"
-#include "phydm_precomp.h"
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
 
 boolean
 odm_check_power_status(void *dm_void)
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_powertracking_ce.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_powertracking_ce.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_powertracking_ce.c
@@ -29,8 +29,8 @@
  *============================================================
  */
 
-#include "mp_precomp.h"
-#include "phydm_precomp.h"
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
 
 /*@************************************************************
  * Global var
@@ -831,7 +831,7 @@ void odm_txpowertracking_check_ce(void *
 			odm_set_rf_reg(dm, RF_PATH_A, R_0x42, BIT(19), 0x01);
 			odm_set_rf_reg(dm, RF_PATH_A, R_0x42, BIT(19), 0x00);
 			odm_set_rf_reg(dm, RF_PATH_A, R_0x42, BIT(19), 0x01);
-			
+
 			odm_set_rf_reg(dm, RF_PATH_B, R_0x42, BIT(19), 0x01);
 			odm_set_rf_reg(dm, RF_PATH_B, R_0x42, BIT(19), 0x00);
 			odm_set_rf_reg(dm, RF_PATH_B, R_0x42, BIT(19), 0x01);
@@ -842,7 +842,7 @@ void odm_txpowertracking_check_ce(void *
 		dm->rf_calibrate_info.tm_trigger = 1;
 		return;
 	}
-	
+
 	if (dm->support_ic_type & ODM_RTL8822C) {
 #if (RTL8822C_SUPPORT == 1)
 		odm_txpowertracking_new_callback_thermal_meter(dm);
@@ -883,7 +883,7 @@ odm_txpowertracking_direct_ce(void *dm_v
 		odm_set_rf_reg(dm, RF_PATH_A, R_0x42, BIT(19), 0x01);
 		odm_set_rf_reg(dm, RF_PATH_A, R_0x42, BIT(19), 0x00);
 		odm_set_rf_reg(dm, RF_PATH_A, R_0x42, BIT(19), 0x01);
-			
+
 		odm_set_rf_reg(dm, RF_PATH_B, R_0x42, BIT(19), 0x01);
 		odm_set_rf_reg(dm, RF_PATH_B, R_0x42, BIT(19), 0x00);
 		odm_set_rf_reg(dm, RF_PATH_B, R_0x42, BIT(19), 0x01);
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_psd.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_psd.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/halrf_psd.c
@@ -18,8 +18,8 @@
  * include files
  *============================================================
  */
-#include "mp_precomp.h"
-#include "phydm_precomp.h"
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
 
 u64 _sqrt(u64 x)
 {
@@ -126,7 +126,7 @@ void halrf_psd(
 	psd->buf_size = 256;
 
 	mode = average >> 16;
-	
+
 	if (mode == 2)
 		average_tmp = 1;
 	else
@@ -259,7 +259,7 @@ void _halrf_psd_iqk_init(struct dm_struc
 	}
 
 	odm_set_bb_reg(dm, 0x1b28, MASKDWORD, 0x0);
-	odm_set_bb_reg(dm, 0x1bcc, 0x3f, 0x3f);	
+	odm_set_bb_reg(dm, 0x1bcc, 0x3f, 0x3f);
 }
 
 
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/rtl8188f/halrf_8188f.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/rtl8188f/halrf_8188f.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/halrf/rtl8188f/halrf_8188f.c
@@ -14,7 +14,7 @@
  *
  *****************************************************************************/
 
-#include "mp_precomp.h"
+#include "../../mp_precomp.h"
 /*#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)*/
 #if (DM_ODM_SUPPORT_TYPE == 0x08) /*[PHYDM-262] workaround for SD4 compile warning*/
 #if RT_PLATFORM == PLATFORM_MACOSX
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/halhwimg8188f_bb.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/halhwimg8188f_bb.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/halhwimg8188f_bb.c
@@ -15,7 +15,7 @@
  *****************************************************************************/
 
 /*Image2HeaderVersion: 3.5.2*/
-#include "mp_precomp.h"
+#include "../mp_precomp.h"
 #include "../phydm_precomp.h"
 
 #if (RTL8188F_SUPPORT == 1)
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/halhwimg8188f_mac.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/halhwimg8188f_mac.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/halhwimg8188f_mac.c
@@ -15,7 +15,7 @@
  *****************************************************************************/
 
 /*Image2HeaderVersion: 3.5.2*/
-#include "mp_precomp.h"
+#include "../mp_precomp.h"
 #include "../phydm_precomp.h"
 
 #if (RTL8188F_SUPPORT == 1)
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/halhwimg8188f_rf.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/halhwimg8188f_rf.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/halhwimg8188f_rf.c
@@ -15,7 +15,7 @@
  *****************************************************************************/
 
 /*Image2HeaderVersion: 3.5.2*/
-#include "mp_precomp.h"
+#include "../mp_precomp.h"
 #include "../phydm_precomp.h"
 
 #if (RTL8188F_SUPPORT == 1)
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/phydm_regconfig8188f.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/phydm_regconfig8188f.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/phydm_regconfig8188f.c
@@ -14,7 +14,7 @@
  *
  *****************************************************************************/
 
-#include "mp_precomp.h"
+#include "../mp_precomp.h"
 #include "../phydm_precomp.h"
 
 #if (RTL8188F_SUPPORT == 1)
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/phydm_rtl8188f.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/phydm_rtl8188f.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/rtl8188f/phydm_rtl8188f.c
@@ -18,7 +18,7 @@
  * include files
  * ************************************************************ */
 
-#include "mp_precomp.h"
+#include "../mp_precomp.h"
 #include "../phydm_precomp.h"
 
 #if (RTL8188F_SUPPORT == 1)
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/txbf/halcomtxbf.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/txbf/halcomtxbf.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/txbf/halcomtxbf.c
@@ -19,7 +19,7 @@
  * This file is for TXBF mechanism
  *
  ************************************************************/
-#include "mp_precomp.h"
+#include "../mp_precomp.h"
 #include "../phydm_precomp.h"
 
 #ifdef PHYDM_BEAMFORMING_SUPPORT
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/txbf/haltxbfinterface.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/txbf/haltxbfinterface.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/txbf/haltxbfinterface.c
@@ -19,7 +19,7 @@
  * This file is for TXBF interface mechanism
  *
  ************************************************************/
-#include "mp_precomp.h"
+#include "../mp_precomp.h"
 #include "../phydm_precomp.h"
 
 #ifdef PHYDM_BEAMFORMING_SUPPORT
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/txbf/phydm_hal_txbf_api.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/txbf/phydm_hal_txbf_api.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/hal/phydm/txbf/phydm_hal_txbf_api.c
@@ -14,8 +14,8 @@
  *
  *****************************************************************************/
 
-#include "mp_precomp.h"
-#include "phydm_precomp.h"
+#include "../mp_precomp.h"
+#include "../phydm_precomp.h"
 
 #if (defined(CONFIG_BB_TXBF_API))
 #if (RTL8822B_SUPPORT == 1 || RTL8192F_SUPPORT == 1 ||\
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/include/rtw_recv.h
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/include/rtw_recv.h
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/include/rtw_recv.h
@@ -381,7 +381,7 @@ struct recv_priv {
 	struct sk_buff_head rx_skb_queue;
 #ifdef CONFIG_RTW_NAPI
 		struct sk_buff_head rx_napi_skb_queue;
-#endif 
+#endif
 #ifdef CONFIG_RX_INDICATE_QUEUE
 	_tasklet rx_indicate_tasklet;
 	struct ifqueue rx_indicate_queue;
@@ -764,8 +764,8 @@ __inline static union recv_frame *rxmem_
 __inline static union recv_frame *pkt_to_recvframe(_pkt *pkt)
 {
 
-	u8 *buf_star;
-	union recv_frame *precv_frame;
+	u8 *buf_star = NULL;
+	union recv_frame *precv_frame = NULL;
 	precv_frame = rxmem_to_recvframe((unsigned char *)buf_star);
 
 	return precv_frame;
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/include/rtw_security.h
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/include/rtw_security.h
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/include/rtw_security.h
@@ -252,7 +252,7 @@ struct security_priv {
 #define SEC_IS_BIP_KEY_INSTALLED(sec) _FALSE
 #endif
 
-struct sha256_state {
+struct sha256_state_ctx {
 	u64 length;
 	u32 state[8], curlen;
 	u8 buf[64];
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/os_dep/linux/ioctl_cfg80211.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/os_dep/linux/ioctl_cfg80211.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/os_dep/linux/ioctl_cfg80211.c
@@ -83,7 +83,7 @@
 #endif
 
 /*
- * In the current design of Wi-Fi driver, it will return success to the system (e.g. supplicant) 
+ * In the current design of Wi-Fi driver, it will return success to the system (e.g. supplicant)
  * when Wi-Fi driver decides to abort the scan request in the scan flow by default.
  * Defining this flag makes Wi-Fi driver to return -EBUSY to the system if Wi-Fi driver is too busy to do the scan.
  */
@@ -220,7 +220,7 @@ static u8 rtw_chbw_to_cfg80211_chan_def(
 	if (!chan)
 		goto exit;
 
-	if (bw == CHANNEL_WIDTH_20) 
+	if (bw == CHANNEL_WIDTH_20)
 		chdef->width = ht ? NL80211_CHAN_WIDTH_20 : NL80211_CHAN_WIDTH_20_NOHT;
 	else if (bw == CHANNEL_WIDTH_40)
 		chdef->width = NL80211_CHAN_WIDTH_40;
@@ -281,7 +281,7 @@ static void rtw_get_chbw_from_cfg80211_c
 		rtw_warn_on(1);
 		*ch = 0;
 		return;
-	}		
+	}
 
 	switch (chdef->width) {
 	case NL80211_CHAN_WIDTH_20_NOHT:
@@ -1622,8 +1622,8 @@ static int rtw_cfg80211_set_encryption(s
 						_rtw_memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 						_rtw_memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 						padapter->securitypriv.binstallGrpkey = _TRUE;
-						if (param->u.crypt.idx < 4) 
-							_rtw_memcpy(padapter->securitypriv.iv_seq[param->u.crypt.idx], param->u.crypt.seq, 8);							
+						if (param->u.crypt.idx < 4)
+							_rtw_memcpy(padapter->securitypriv.iv_seq[param->u.crypt.idx], param->u.crypt.seq, 8);
 						padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
 						rtw_set_key(padapter, &padapter->securitypriv, param->u.crypt.idx, 1, _TRUE);
 
@@ -1871,7 +1871,7 @@ static int cfg80211_rtw_get_key(struct w
 		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE)
 		|| (MLME_IS_STA(adapter) && !pairwise)
 		#endif
-	) {	
+	) {
 		/* WEP key, TX GTK/IGTK, RX GTK/IGTK(for STA mode) */
 		if (is_wep_enc(sec->dot118021XGrpPrivacy)) {
 			if (keyid >= WEP_KEYS)
@@ -1960,7 +1960,7 @@ static int cfg80211_rtw_get_key(struct w
 	}
 
 	ret = 0;
-	
+
 exit:
 	RTW_INFO(FUNC_NDEV_FMT
 		GET_KEY_PARAM_FMT_S
@@ -5697,7 +5697,7 @@ release_plink_ctl:
 		if (del_sta) {
 			u8 sta_addr[ETH_ALEN];
 			u8 updated = _FALSE;
-			
+
 			_rtw_memcpy(sta_addr, del_sta->cmn.mac_addr, ETH_ALEN);
 			updated = ap_free_sta(adapter, del_sta, 0, 0, 1);
 			rtw_mesh_expire_peer(stapriv->padapter, sta_addr);
@@ -5783,7 +5783,7 @@ static int	cfg80211_rtw_dump_station(str
 	else
 		_rtw_memcpy(mac, plink->addr, ETH_ALEN);
 	#endif
-	
+
 	sinfo->filled = 0;
 
 	if (psta) {
@@ -7500,13 +7500,22 @@ static void cfg80211_rtw_mgmt_frame_regi
 #else
 	struct net_device *ndev,
 #endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
+	struct mgmt_frame_regs *upd)
+#else
 	u16 frame_type, bool reg)
+#endif
 {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
 	struct net_device *ndev = wdev_to_ndev(wdev);
 #endif
 	_adapter *adapter;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
+	u16 frame_type = BIT(upd->global_stypes << 4);
+	bool reg = false;
+#endif
+
 	struct rtw_wdev_priv *pwdev_priv;
 
 	if (ndev == NULL)
@@ -7886,7 +7895,7 @@ void dump_mesh_config(void *sel, const s
 	RTW_PRINT_SEL(sel, "path_refresh_time:%u\n", conf->path_refresh_time);
 	RTW_PRINT_SEL(sel, "min_discovery_timeout:%u\n", conf->min_discovery_timeout);
 	RTW_PRINT_SEL(sel, "dot11MeshHWMPactivePathTimeout:%u\n", conf->dot11MeshHWMPactivePathTimeout);
-	RTW_PRINT_SEL(sel, "dot11MeshHWMPpreqMinInterval:%u\n", conf->dot11MeshHWMPpreqMinInterval);	
+	RTW_PRINT_SEL(sel, "dot11MeshHWMPpreqMinInterval:%u\n", conf->dot11MeshHWMPpreqMinInterval);
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
 	RTW_PRINT_SEL(sel, "dot11MeshHWMPperrMinInterval:%u\n", conf->dot11MeshHWMPperrMinInterval);
 #endif
@@ -7901,11 +7910,11 @@ void dump_mesh_config(void *sel, const s
 	RTW_PRINT_SEL(sel, "dot11MeshForwarding:%d\n", conf->dot11MeshForwarding);
 	RTW_PRINT_SEL(sel, "rssi_threshold:%d\n", conf->rssi_threshold);
 #endif
-	
+
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0))
 	RTW_PRINT_SEL(sel, "ht_opmode:0x%04x\n", conf->ht_opmode);
 #endif
-	
+
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
 	RTW_PRINT_SEL(sel, "dot11MeshHWMPactivePathToRootTimeout:%u\n", conf->dot11MeshHWMPactivePathToRootTimeout);
 	RTW_PRINT_SEL(sel, "dot11MeshHWMProotInterval:%u\n", conf->dot11MeshHWMProotInterval);
@@ -7916,7 +7925,7 @@ void dump_mesh_config(void *sel, const s
 	RTW_PRINT_SEL(sel, "power_mode:%s\n", nl80211_mesh_power_mode_str(conf->power_mode));
 	RTW_PRINT_SEL(sel, "dot11MeshAwakeWindowDuration:%u\n", conf->dot11MeshAwakeWindowDuration);
 #endif
-	
+
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0))
 	RTW_PRINT_SEL(sel, "plink_timeout:%u\n", conf->plink_timeout);
 #endif
@@ -8052,14 +8061,14 @@ static void rtw_cfg80211_mesh_cfg_set(_a
 	if (chk_mesh_attr(NL80211_MESHCONF_HT_OPMODE, mask));
 #endif
 #endif
-	
+
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
 	if (chk_mesh_attr(NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT, mask))
 		mcfg->dot11MeshHWMPactivePathToRootTimeout = conf->dot11MeshHWMPactivePathToRootTimeout;
 	if (chk_mesh_attr(NL80211_MESHCONF_HWMP_ROOT_INTERVAL, mask))
 		mcfg->dot11MeshHWMProotInterval = conf->dot11MeshHWMProotInterval;
 	if (chk_mesh_attr(NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL, mask))
-		mcfg->dot11MeshHWMPconfirmationInterval = conf->dot11MeshHWMPconfirmationInterval;	
+		mcfg->dot11MeshHWMPconfirmationInterval = conf->dot11MeshHWMPconfirmationInterval;
 #endif
 
 #if 0 /* TBD */
@@ -8117,7 +8126,7 @@ u8 *rtw_cfg80211_construct_mesh_beacon_i
 #endif
 	if (!ch)
 		goto exit;
-	
+
 #if defined(CONFIG_80211AC_VHT) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
 	vht = ht && ch > 14 && bw >= CHANNEL_WIDTH_80; /* VHT40/VHT20? */
 #endif
@@ -8448,7 +8457,7 @@ static int cfg80211_rtw_join_mesh(struct
 		ret = -EINVAL;
 		goto exit;
 	}
-	
+
 	rtw_mesh_work(&adapter->mesh_work);
 
 exit:
@@ -8529,7 +8538,7 @@ static int cfg80211_rtw_del_mpath(struct
 		}
 	} else {
 		rtw_mesh_path_flush_by_iface(adapter);
-	}	
+	}
 
 exit:
 	return ret;
@@ -8830,13 +8839,13 @@ int	cfg80211_rtw_resume(struct wiphy *wi
 		//rtw_sitesurvey_cmd(padapter, NULL);
 		rtw_sitesurvey_cmd(padapter, &parm);
 		_exit_critical_bh(&pmlmepriv->lock, &irqL);
-		
+
 		for (PNOWakeupScanWaitCnt = 0; PNOWakeupScanWaitCnt < 10; PNOWakeupScanWaitCnt++) {
 			if(check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _FALSE)
 				break;
 			rtw_msleep_os(1000);
 		}
-		
+
 		_enter_critical_bh(&pmlmepriv->lock, &irqL);
 		cfg80211_sched_scan_results(padapter->rtw_wdev->wiphy);
 		_exit_critical_bh(&pmlmepriv->lock, &irqL);
@@ -8844,7 +8853,7 @@ int	cfg80211_rtw_resume(struct wiphy *wi
 	}
 	RTW_DBG("<== %s\n",__func__);
 	return 0;
-	
+
 }
 #endif /* CONFIG_PNO_SUPPORT */
 
@@ -9738,7 +9747,7 @@ int rtw_hostapd_acs_dump_survey(struct w
 #elif defined(CONFIG_RTW_ACS) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
 	rtw_cfg80211_set_survey_info_with_clm(padapter, idx, info);
 #else
-	RTW_ERR("%s: unknown acs operation!\n", __func__); 
+	RTW_ERR("%s: unknown acs operation!\n", __func__);
 #endif
 
 	return ret;
@@ -9929,7 +9938,11 @@ static struct cfg80211_ops rtw_cfg80211_
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE)
 	.mgmt_tx = cfg80211_rtw_mgmt_tx,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
+	.update_mgmt_frame_registrations = cfg80211_rtw_mgmt_frame_register,
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	.mgmt_frame_register = cfg80211_rtw_mgmt_frame_register,
+#endif
 #elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34) && LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 	.action = cfg80211_rtw_mgmt_tx,
 #endif
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/os_dep/linux/rtw_proc.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/os_dep/linux/rtw_proc.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/os_dep/linux/rtw_proc.c
@@ -63,7 +63,12 @@ inline struct proc_dir_entry *rtw_proc_c
 }
 
 inline struct proc_dir_entry *rtw_proc_create_entry(const char *name, struct proc_dir_entry *parent,
-	const struct file_operations *fops, void * data)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
+	const struct file_operations *fops,
+#else
+	const struct proc_ops *fops,
+#endif
+  void * data)
 {
 	struct proc_dir_entry *entry;
 
@@ -239,15 +244,7 @@ static ssize_t rtw_drv_proc_write(struct
 	return -EROFS;
 }
 
-static const struct file_operations rtw_drv_proc_seq_fops = {
-	.owner = THIS_MODULE,
-	.open = rtw_drv_proc_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = seq_release,
-	.write = rtw_drv_proc_write,
-};
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
 static const struct file_operations rtw_drv_proc_sseq_fops = {
 	.owner = THIS_MODULE,
 	.open = rtw_drv_proc_open,
@@ -256,6 +253,34 @@ static const struct file_operations rtw_
 	.release = single_release,
 	.write = rtw_drv_proc_write,
 };
+#else
+static const struct proc_ops rtw_drv_proc_sseq_fops = {
+	.proc_open = rtw_drv_proc_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+	.proc_write = rtw_drv_proc_write,
+};
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
+static const struct file_operations rtw_drv_proc_seq_fops = {
+  .owner = THIS_MODULE,
+  .open = rtw_drv_proc_open,
+  .read = seq_read,
+  .llseek = seq_lseek,
+  .release = seq_release,
+  .write = rtw_drv_proc_write,
+};
+#else
+static const struct proc_ops rtw_drv_proc_seq_fops = {
+  .proc_open = rtw_drv_proc_open,
+  .proc_read = seq_read,
+  .proc_lseek = seq_lseek,
+  .proc_release = seq_release,
+  .proc_write = rtw_drv_proc_write,
+};
+#endif
 
 int rtw_drv_proc_init(void)
 {
@@ -1034,15 +1059,15 @@ static int proc_get_turboedca_ctrl(struc
 		u32 edca_param;
 
 		if (hal_data->dis_turboedca == 0)
-			RTW_PRINT_SEL(m, "Turbo-EDCA : %s\n", "Enable"); 
-		else 		
+			RTW_PRINT_SEL(m, "Turbo-EDCA : %s\n", "Enable");
+		else
 			RTW_PRINT_SEL(m, "Turbo-EDCA : %s, mode=%d, edca_param_mode=0x%x\n", "Disable", hal_data->dis_turboedca, hal_data->edca_param_mode);
 
 
 		rtw_hal_get_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&edca_param));
 
 		_RTW_PRINT_SEL(m, "PARAM_BE:0x%x\n", edca_param);
-		
+
 	}
 
 	return 0;
@@ -1073,28 +1098,28 @@ static ssize_t proc_set_turboedca_ctrl(s
 		}
 
 		/*  0: enable turboedca,
-			1: disable turboedca, 
+			1: disable turboedca,
 			2: disable turboedca and setting EDCA parameter based on the input parameter
-			> 2 : currently reset to 0 */ 
-			
-		if (mode > 2) 
+			> 2 : currently reset to 0 */
+
+		if (mode > 2)
 			mode = 0;
 
 		hal_data->dis_turboedca = mode;
-		
+
 		hal_data->edca_param_mode = 0; /* init. value */
 
 		RTW_INFO("dis_turboedca mode = 0x%x\n", hal_data->dis_turboedca);
-		
+
 		if (num == 2) {
 
-			hal_data->edca_param_mode = param_mode;			
+			hal_data->edca_param_mode = param_mode;
 
 			RTW_INFO("param_mode = 0x%x\n", param_mode);
 		}
-		
+
 	}
-	
+
 	return count;
 
 }
@@ -1228,7 +1253,7 @@ ssize_t proc_set_macaddr_acl(struct file
 #define MAC_ACL_CMD_DEL		2
 #define MAC_ACL_CMD_CLR		3
 #define MAC_ACL_CMD_NUM		4
-	
+
 	static const char * const mac_acl_cmd_str[] = {
 		"mode",
 		"add",
@@ -1330,7 +1355,7 @@ ssize_t proc_set_macaddr_acl(struct file
 				 } else if (!is_bcast)
 					rtw_acl_add_sta(adapter, period, addr);
 			}
-		
+
 			c = strsep(&next, " \t");
 		}
 	}
@@ -1740,7 +1765,7 @@ static ssize_t proc_set_rx_chk_limit(str
 		RTW_INFO("argument size is less than 1\n");
 		return -EFAULT;
 	}
-	
+
 	if (count > sizeof(tmp)) {
 		rtw_warn_on(1);
 		return -EFAULT;
@@ -2158,7 +2183,7 @@ static void rtw_set_tx_bw_mode(struct _A
 	) {
 		/* RA mask update needed */
 		update = _TRUE;
-	}		
+	}
 	adapter->driver_tx_bw_mode = bw_mode;
 
 	if (update == _TRUE) {
@@ -3278,7 +3303,7 @@ static ssize_t proc_set_napi_th(struct f
 
 	for (i = 0; i < dvobj->iface_nums; i++) {
 		iface = dvobj->padapters[i];
-		if (iface) {	
+		if (iface) {
 			if (buffer && !copy_from_user(tmp, buffer, count)) {
 				registry = &iface->registrypriv;
 				num = sscanf(tmp, "%d", &thrshld);
@@ -3758,7 +3783,7 @@ static int proc_get_peer_alive_based_pre
 	return 0;
 }
 
-static ssize_t 
+static ssize_t
 proc_set_peer_alive_based_preq(struct file *file, const char __user *buffer,
 			       size_t count, loff_t *pos, void *data)
 {
@@ -3858,7 +3883,7 @@ static void tpt_mode_default(struct _ADA
 	dvobj->scan_deny = _FALSE;
 
 	/* 2. back to original LPS mode */
-#ifdef CONFIG_LPS		
+#ifdef CONFIG_LPS
 	rtw_pm_set_lps(adapter, adapter->registrypriv.power_mgnt);
 #endif
 
@@ -3873,13 +3898,13 @@ static void rtw_tpt_mode(struct _ADAPTER
 
 	if (dvobj->tpt_mode > 0) {
 
-		/* when enable each tpt mode 
+		/* when enable each tpt mode
 			1. scan deny
 			2. disable LPS */
-			
+
 		dvobj->scan_deny = _TRUE;
 
-#ifdef CONFIG_LPS		
+#ifdef CONFIG_LPS
 		rtw_pm_set_lps(adapter, PS_MODE_ACTIVE);
 #endif
 
@@ -3890,9 +3915,9 @@ static void rtw_tpt_mode(struct _ADAPTER
 			tpt_mode_default(adapter);
 			break;
 		case 1: /* High TP*/
-			/*tpt_mode1(adapter);*/			 
+			/*tpt_mode1(adapter);*/
 			dvobj->edca_be_ul = 0x5e431c;
-			dvobj->edca_be_dl = 0x00431c;			 
+			dvobj->edca_be_dl = 0x00431c;
 			break;
 		case 2: /* noise */
 			/* tpt_mode2(adapter); */
@@ -3916,7 +3941,7 @@ static void rtw_tpt_mode(struct _ADAPTER
 			rtw_set_tx_bw_mode(adapter, 0x20); /* for 2.4g, fixed tx_bw_mode to 20Mhz */
 			break;
 		default: /* default mode */
-			tpt_mode_default(adapter);		
+			tpt_mode_default(adapter);
 			break;
 	}
 
@@ -3949,7 +3974,7 @@ static ssize_t proc_set_tpt_mode(struct
 	}
 
 	if (mode > MAX_TPT_MODE_NUM )
-		mode = 0;	
+		mode = 0;
 
 	RTW_PRINT("%s: previous mode =  %d\n",
 		  __FUNCTION__, dvobj->tpt_mode);
@@ -4214,7 +4239,7 @@ const struct rtw_proc_hdl adapter_proc_h
 	RTW_PROC_HDL_SSEQ("ps_info", proc_get_ps_info, proc_set_ps_info),
 #ifdef CONFIG_WMMPS_STA
 	RTW_PROC_HDL_SSEQ("wmmps_info", proc_get_wmmps_info, proc_set_wmmps_info),
-#endif /* CONFIG_WMMPS_STA */	
+#endif /* CONFIG_WMMPS_STA */
 #endif
 #ifdef CONFIG_TDLS
 	RTW_PROC_HDL_SSEQ("tdls_info", proc_get_tdls_info, NULL),
@@ -4377,7 +4402,7 @@ static ssize_t rtw_adapter_proc_write(st
 
 	return -EROFS;
 }
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
 static const struct file_operations rtw_adapter_proc_seq_fops = {
 	.owner = THIS_MODULE,
 	.open = rtw_adapter_proc_open,
@@ -4395,7 +4420,23 @@ static const struct file_operations rtw_
 	.release = single_release,
 	.write = rtw_adapter_proc_write,
 };
+#else
+static const struct proc_ops rtw_adapter_proc_seq_fops = {
+  .proc_open = rtw_adapter_proc_open,
+  .proc_read = seq_read,
+  .proc_lseek = seq_lseek,
+  .proc_release = seq_release,
+  .proc_write = rtw_adapter_proc_write,
+};
 
+static const struct proc_ops rtw_adapter_proc_sseq_fops = {
+  .proc_open = rtw_adapter_proc_open,
+  .proc_read = seq_read,
+  .proc_lseek = seq_lseek,
+  .proc_release = single_release,
+  .proc_write = rtw_adapter_proc_write,
+};
+#endif
 int proc_get_odm_adaptivity(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
@@ -4547,6 +4588,7 @@ static ssize_t rtw_odm_proc_write(struct
 	return -EROFS;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
 static const struct file_operations rtw_odm_proc_seq_fops = {
 	.owner = THIS_MODULE,
 	.open = rtw_odm_proc_open,
@@ -4564,6 +4606,23 @@ static const struct file_operations rtw_
 	.release = single_release,
 	.write = rtw_odm_proc_write,
 };
+#else
+static const struct proc_ops rtw_odm_proc_seq_fops = {
+  .proc_open = rtw_odm_proc_open,
+  .proc_read = seq_read,
+  .proc_lseek = seq_lseek,
+  .proc_release = seq_release,
+  .proc_write = rtw_odm_proc_write,
+};
+
+static const struct proc_ops rtw_odm_proc_sseq_fops = {
+  .proc_open = rtw_odm_proc_open,
+  .proc_read = seq_read,
+  .proc_lseek = seq_lseek,
+  .proc_release = single_release,
+  .proc_write = rtw_odm_proc_write,
+};
+#endif
 
 struct proc_dir_entry *rtw_odm_proc_init(struct net_device *dev)
 {
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/mesh/rtw_mesh.h
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/mesh/rtw_mesh.h
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/mesh/rtw_mesh.h
@@ -15,7 +15,7 @@
  *****************************************************************************/
 #ifndef __RTW_MESH_H_
 #define __RTW_MESH_H_
-
+#include <drv_types.h>
 #ifndef CONFIG_AP_MODE
 	#error "CONFIG_RTW_MESH can't be enabled when CONFIG_AP_MODE is not defined\n"
 #endif
@@ -378,7 +378,7 @@ struct rtw_mesh_info {
 	systime next_perr;
 	/* Last used Path Discovery ID */
 	u32 preq_id;
-	
+
 	ATOMIC_T mpaths;
 	struct rtw_mesh_table *mesh_paths;
 	struct rtw_mesh_table *mpp_paths;
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_mlme.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_mlme.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_mlme.c
@@ -16,6 +16,7 @@
 #define _RTW_MLME_C_
 
 #include <hal_data.h>
+#include <drv_types.h>
 
 extern void indicate_wx_scan_complete_event(_adapter *padapter);
 extern u8 rtw_do_join(_adapter *padapter);
@@ -140,7 +141,7 @@ sint	_rtw_init_mlme_priv(_adapter *padap
 #if defined(CONFIG_RTW_WNM) || defined(CONFIG_RTW_80211K)
 	rtw_roam_nb_info_init(padapter);
 	pmlmepriv->ch_cnt = 0;
-#endif	
+#endif
 #endif
 	rtw_init_mlme_timer(padapter);
 
@@ -699,8 +700,8 @@ int is_same_network(WLAN_BSSID_EX *src,
 		return _TRUE;
 #endif
 
-	/* Wi-Fi driver doesn't consider the situation of BCN and ProbRsp sent from the same hidden AP, 
-	  * it considers these two packets are sent from different AP. 
+	/* Wi-Fi driver doesn't consider the situation of BCN and ProbRsp sent from the same hidden AP,
+	  * it considers these two packets are sent from different AP.
 	  * Therefore, the scan queue may store two scan results of the same hidden AP, likes below.
 	  *
 	  *  index            bssid              ch    RSSI   SdBm  Noise   age          flag             ssid
@@ -713,11 +714,11 @@ int is_same_network(WLAN_BSSID_EX *src,
 	  * It means the scan queue will not store two scan results of the same hidden AP, it only store ProbRsp.
 	  * For customer request.
 	  */
-	  
+
 	if (((_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == _TRUE) &&
 		((s_cap & WLAN_CAPABILITY_IBSS) == (d_cap & WLAN_CAPABILITY_IBSS)) &&
 		((s_cap & WLAN_CAPABILITY_BSS) == (d_cap & WLAN_CAPABILITY_BSS))) {
-		if ((src->Ssid.SsidLength == dst->Ssid.SsidLength) && 
+		if ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
 			(((_rtw_memcmp(src->Ssid.Ssid, dst->Ssid.Ssid, src->Ssid.SsidLength)) == _TRUE) || //Case of normal AP
 			(is_all_null(src->Ssid.Ssid, src->Ssid.SsidLength) == _TRUE || is_all_null(dst->Ssid.Ssid, dst->Ssid.SsidLength) == _TRUE))) //Case of hidden AP
 			return _TRUE;
@@ -994,7 +995,7 @@ bool rtw_update_scanned_network(_adapter
 			plist = get_next(plist);
 			continue;
 		}
-			
+
 #ifdef CONFIG_RSSI_PRIORITY
 		if ((choice == NULL) || (pnetwork->network.PhyInfo.SignalStrength < choice->network.PhyInfo.SignalStrength))
 			#ifdef CONFIG_RTW_MESH
@@ -2603,10 +2604,10 @@ u8 rtw_ft_chk_roaming_candidate(
 	/*The candidate don't support over-the-DS*/
 	if (rtw_ft_valid_otd_candidate(padapter, pmdie)) {
 		RTW_INFO("FT: ignore the candidate("
-			MAC_FMT ") for over-the-DS\n", 
+			MAC_FMT ") for over-the-DS\n",
 			MAC_ARG(competitor->network.MacAddress));
 			rtw_ft_clr_flags(padapter, RTW_FT_PEER_OTD_EN);
-		return _FALSE;	
+		return _FALSE;
 	}
 
 	return _TRUE;
@@ -2682,7 +2683,7 @@ err_2:
 void rtw_roam_nb_info_init(_adapter *padapter)
 {
 	struct roam_nb_info *pnb = &(padapter->mlmepriv.nb_info);
-	
+
 	_rtw_memset(&pnb->nb_rpt, 0, sizeof(pnb->nb_rpt));
 	_rtw_memset(&pnb->nb_rpt_ch_list, 0, sizeof(pnb->nb_rpt_ch_list));
 	_rtw_memset(&pnb->roam_target_addr, 0, ETH_ALEN);
@@ -2692,8 +2693,8 @@ void rtw_roam_nb_info_init(_adapter *pad
 	pnb->nb_rpt_is_same = _TRUE;
 	pnb->last_nb_rpt_entries = 0;
 #ifdef CONFIG_RTW_WNM
-	rtw_init_timer(&pnb->roam_scan_timer, 
-		padapter, rtw_wnm_roam_scan_hdl, 
+	rtw_init_timer(&pnb->roam_scan_timer,
+		padapter, rtw_wnm_roam_scan_hdl,
 		padapter);
 #endif
 }
@@ -2721,7 +2722,7 @@ u8 rtw_roam_nb_scan_list_set(
 	rtw_init_sitesurvey_parm(padapter, pparm);
 	if (rtw_roam_busy_scan(padapter, pnb)) {
 		pparm->ch_num = 1;
-		pparm->ch[pmlmepriv->ch_cnt].hw_value = 
+		pparm->ch[pmlmepriv->ch_cnt].hw_value =
 			pnb->nb_rpt_ch_list[pmlmepriv->ch_cnt].hw_value;
 		pmlmepriv->ch_cnt++;
 		ret = _TRUE;
@@ -2740,7 +2741,7 @@ u8 rtw_roam_nb_scan_list_set(
 	}
 
 	pmlmepriv->nb_info.nb_rpt_valid = _FALSE;
-	pmlmepriv->ch_cnt = 0;		
+	pmlmepriv->ch_cnt = 0;
 	ret = _TRUE;
 
 set_bssid_list:
@@ -3070,7 +3071,7 @@ void rtw_scan_timeout_handler(void *ctx)
 void rtw_mlme_reset_auto_scan_int(_adapter *adapter, u8 *reason)
 {
 #if defined(CONFIG_RTW_MESH) && defined(CONFIG_DFS_MASTER)
-#if CONFIG_RTW_MESH_OFFCH_CAND 
+#if CONFIG_RTW_MESH_OFFCH_CAND
 	struct rf_ctl_t *rfctl = adapter_to_rfctl(adapter);
 #endif
 #endif
@@ -3184,7 +3185,7 @@ void rtw_drv_scan_by_self(_adapter *pada
 	}
 
 #if defined(CONFIG_RTW_WNM) || defined(CONFIG_RTW_80211K)
-	if ((reason == RTW_AUTO_SCAN_REASON_ROAM) 
+	if ((reason == RTW_AUTO_SCAN_REASON_ROAM)
 		&& (rtw_roam_nb_scan_list_set(padapter, &parm)))
 		goto exit;
 #endif
@@ -3414,7 +3415,7 @@ static void collect_traffic_statistics(_
 	dynamic_napi_th_chk (padapter);
 #endif /* CONFIG_RTW_NAPI_DYNAMIC */
 #endif
-	
+
 }
 
 void rtw_dynamic_check_timer_handlder(void *ctx)
@@ -3548,10 +3549,10 @@ static int rtw_check_roaming_candidate(s
 		goto exit;
 
 #if defined(CONFIG_RTW_80211R) && defined(CONFIG_RTW_WNM)
-	if (rtw_wnm_btm_diff_bss(adapter) && 
+	if (rtw_wnm_btm_diff_bss(adapter) &&
 		rtw_wnm_btm_roam_candidate(adapter, competitor)) {
 		goto update;
-	}	
+	}
 #endif
 
 	if (competitor->network.Rssi - mlme->cur_network_scanned->network.Rssi < mlme->roam_rssi_diff_th)
@@ -3995,9 +3996,9 @@ exit:
 /*
  * rtw_uapsd_use_default_setting
  * This function is used for setting default uapsd max sp length to uapsd_max_sp_len
- * in qos_priv data structure from registry. In additional, it will also map default uapsd 
- * ac to each uapsd TID, delivery-enabled and trigger-enabled of corresponding TID. 
- * 
+ * in qos_priv data structure from registry. In additional, it will also map default uapsd
+ * ac to each uapsd TID, delivery-enabled and trigger-enabled of corresponding TID.
+ *
  * Arguments:
  * @padapter: _adapter pointer.
  *
@@ -4012,7 +4013,7 @@ void	rtw_uapsd_use_default_setting(_adap
 
 	if (pregistrypriv->uapsd_ac_enable != 0) {
 		pqospriv->uapsd_max_sp_len = pregistrypriv->uapsd_max_sp_len;
-		
+
 		CLEAR_FLAGS(pqospriv->uapsd_tid);
 		CLEAR_FLAGS(pqospriv->uapsd_tid_delivery_enabled);
 		CLEAR_FLAGS(pqospriv->uapsd_tid_trigger_enabled);
@@ -4028,7 +4029,7 @@ void	rtw_uapsd_use_default_setting(_adap
 		}
 
 		/* check the uapsd setting of AC_VI from registry then map these setting to each TID if necessary  */
-		if(TEST_FLAG(pregistrypriv->uapsd_ac_enable, DRV_CFG_UAPSD_VI)) {	
+		if(TEST_FLAG(pregistrypriv->uapsd_ac_enable, DRV_CFG_UAPSD_VI)) {
 			SET_FLAG(pqospriv->uapsd_tid, WMM_TID5);
 			SET_FLAG(pqospriv->uapsd_tid_delivery_enabled, WMM_TID5);
 			SET_FLAG(pqospriv->uapsd_tid_trigger_enabled, WMM_TID5);
@@ -4057,7 +4058,7 @@ void	rtw_uapsd_use_default_setting(_adap
 			SET_FLAG(pqospriv->uapsd_tid_trigger_enabled, WMM_TID0);
 		}
 
-		RTW_INFO("[WMMPS] UAPSD MAX SP Len = 0x%02x, UAPSD TID enabled = 0x%02x\n", 
+		RTW_INFO("[WMMPS] UAPSD MAX SP Len = 0x%02x, UAPSD TID enabled = 0x%02x\n",
 			pqospriv->uapsd_max_sp_len, (u8)pqospriv->uapsd_tid);
 	}
 
@@ -4067,18 +4068,18 @@ void	rtw_uapsd_use_default_setting(_adap
  * rtw_is_wmmps_mode
  * This function is used for checking whether Driver and an AP support uapsd function or not.
  * If both of them support uapsd function, it will return true. Otherwise returns false.
- * 
+ *
  * Arguments:
  * @padapter: _adapter pointer.
  *
  * Auther: Arvin Liu
  * Date: 2017/06/12
  */
-bool rtw_is_wmmps_mode(_adapter *padapter) 
+bool rtw_is_wmmps_mode(_adapter *padapter)
 {
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	struct qos_priv	*pqospriv = &pmlmepriv->qospriv;
-		
+
 	if ((pqospriv->uapsd_ap_supported) && ((pqospriv->uapsd_tid & BIT_MASK_TID_TC)  != 0))
 		return _TRUE;
 
@@ -4121,16 +4122,16 @@ int rtw_restruct_wmm_ie(_adapter *adapte
 
 #ifdef CONFIG_WMMPS_STA
 			switch(pqospriv->uapsd_max_sp_len) {
-				case NO_LIMIT: 
+				case NO_LIMIT:
 					/* do nothing */
 					break;
-				case TWO_MSDU: 
+				case TWO_MSDU:
 					SET_FLAG(qos_info, BIT5);
 					break;
-				case FOUR_MSDU: 
+				case FOUR_MSDU:
 					SET_FLAG(qos_info, BIT6);
-					break;	
-				case SIX_MSDU: 
+					break;
+				case SIX_MSDU:
 					SET_FLAG(qos_info, BIT5);
 					SET_FLAG(qos_info, BIT6);
 					break;
@@ -4152,7 +4153,7 @@ int rtw_restruct_wmm_ie(_adapter *adapte
 			if((TEST_FLAG(pqospriv->uapsd_tid, WMM_TID3)) && (TEST_FLAG(pqospriv->uapsd_tid, WMM_TID0)))
 				SET_FLAG(qos_info, WMM_IE_UAPSD_BE);
 #endif /* CONFIG_WMMPS_STA */
-			
+
 			out_ie[initial_out_len + 8] = qos_info;
 
 			break;
@@ -4263,7 +4264,7 @@ int rtw_rsn_sync_pmkid(_adapter *adapter
 		+ 2 + 16 * info.pmkid_cnt
 		+ (info.gmcs ? 4 : 0)
 		;
-	
+
 	ie[1] = (u8)(ie_len - 2);
 
 exit:
@@ -4796,7 +4797,7 @@ void rtw_update_ht_cap(_adapter *padapte
 			phtpriv->ampdu_enable = _TRUE;
 		} else
 			phtpriv->ampdu_enable = _TRUE;
-	} 
+	}
 
 
 	/* check Max Rx A-MPDU Size */
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_odm.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_odm.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_odm.c
@@ -13,7 +13,7 @@
  * more details.
  *
  *****************************************************************************/
-
+#include <drv_types.h>
 #include <rtw_odm.h>
 #include <hal_data.h>
 
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_wlan_util.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_wlan_util.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/core/rtw_wlan_util.c
@@ -1558,7 +1558,7 @@ void WMMOnAssocRsp(_adapter *padapter)
 #ifdef CONFIG_WMMPS_STA
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	struct qos_priv	*pqospriv = &pmlmepriv->qospriv;
-#endif /* CONFIG_WMMPS_STA */	
+#endif /* CONFIG_WMMPS_STA */
 
 	acm_mask = 0;
 
@@ -1684,7 +1684,7 @@ void WMMOnAssocRsp(_adapter *padapter)
 			pxmitpriv->wmm_para_seq[i] = inx[i];
 			RTW_INFO("wmm_para_seq(%d): %d\n", i, pxmitpriv->wmm_para_seq[i]);
 		}
-		
+
 #ifdef CONFIG_WMMPS_STA
 		/* if AP supports UAPSD function, driver must set each uapsd TID to coresponding mac register 0x693 */
 		if (pmlmeinfo->WMM_param.QoS_info & AP_SUPPORTED_UAPSD) {
@@ -2332,11 +2332,11 @@ inline bool match_ranges(u16 EID, u32 va
 /*
  * rtw_validate_value: validate the IE contain.
  *
- *	Input : 
+ *	Input :
  *		EID : Element ID
  *		p	: IE buffer (without EID & length)
  *		len	: IE length
- *	return: 
+ *	return:
  * 		_TRUE	: All Values are validated.
  *		_FALSE	: At least one value is NOT validated.
  */
@@ -2363,7 +2363,7 @@ bool rtw_validate_value(u16 EID, u8 *p,
 
 inline bool hidden_ssid_ap(WLAN_BSSID_EX *snetwork)
 {
-	return ((snetwork->Ssid.SsidLength == 0) ||  
+	return ((snetwork->Ssid.SsidLength == 0) ||
 		is_all_null(snetwork->Ssid.Ssid, snetwork->Ssid.SsidLength) == _TRUE);
 }
 
@@ -2401,7 +2401,7 @@ void rtw_absorb_ssid_ifneed(_adapter *pa
 			ie_offset = _FIXED_IE_LENGTH_;
 		}
 	}
-	
+
 	_enter_critical_bh(&padapter->mlmepriv.scanned_queue.lock, &irqL);
 	scanned = _rtw_find_network(&padapter->mlmepriv.scanned_queue, mac);
 	if (!scanned) {
@@ -3178,7 +3178,7 @@ unsigned char check_assoc_AP(u8 *pframe,
 void get_assoc_AP_Vendor(char *vendor, u8 assoc_AP_vendor)
 {
 	switch (assoc_AP_vendor) {
-	
+
 	case HT_IOT_PEER_UNKNOWN:
 	sprintf(vendor, "%s", "unknown");
 	break;
@@ -3238,7 +3238,7 @@ void rtw_parse_sta_vendor_ie_8812(_adapt
 
 			if(*(p+6) != 2)
 				goto exit;
-			
+
 			if(*(p+8) == RT_HT_CAP_USE_JAGUAR_BCUT)
 				sta->vendor_8812 = TRUE;
 			else if (*(p+8) == RT_HT_CAP_USE_JAGUAR_CCUT)
@@ -3465,7 +3465,7 @@ int rtw_ies_get_supported_rate(u8 *ies,
 		{IEEE80211_OFDM_RATE_48MB,		_FALSE,		_FALSE},
 		{IEEE80211_OFDM_RATE_54MB,		_FALSE,		_FALSE},
 	};
-		
+
 	if (!rate_set || !rate_num)
 		return _FALSE;
 
@@ -5016,3 +5016,5 @@ inline void rtw_collect_bcn_info(_adapte
 	/*TODO get offset of bcn's timestamp*/
 	/*pmlmeext->bcn_timestamp;*/
 }
+
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/include/ieee80211.h
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/include/ieee80211.h
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/include/ieee80211.h
@@ -15,7 +15,7 @@
  *****************************************************************************/
 #ifndef __IEEE80211_H
 #define __IEEE80211_H
-
+#include <linux/etherdevice.h>
 #define MGMT_QUEUE_NUM 5
 
 #define ETH_ALEN	6
@@ -668,7 +668,7 @@ struct ieee80211_snap_hdr {
 #define WLAN_REASON_MESH_MAX_PEERS 53
 #define WLAN_REASON_MESH_CONFIG 54
 #define WLAN_REASON_MESH_CLOSE 55
-#define WLAN_REASON_MESH_MAX_RETRIES 56 
+#define WLAN_REASON_MESH_MAX_RETRIES 56
 #define WLAN_REASON_MESH_CONFIRM_TIMEOUT 57
 #define WLAN_REASON_MESH_INVALID_GTK 58
 #define WLAN_REASON_MESH_INCONSISTENT_PARAM 59
@@ -1453,6 +1453,10 @@ enum ieee80211_state {
 	(((Addr[2]) & 0xff) == 0xff) && (((Addr[3]) & 0xff) == 0xff) && (((Addr[4]) & 0xff) == 0xff) && \
 				     (((Addr[5]) & 0xff) == 0xff))
 #else
+#define is_multicast_mac_addr(Addr) is_multicast_ether_addr(Addr)
+#define is_broadcast_mac_addr(Addr) is_broadcast_ether_addr(Addr)
+#define is_zero_mac_addr(Addr) is_zero_ether_addr(Addr)
+/*
 extern __inline int is_multicast_mac_addr(const u8 *addr)
 {
 	return (addr[0] != 0xff) && (0x01 & addr[0]);
@@ -1469,6 +1473,7 @@ extern __inline int is_zero_mac_addr(con
 	return ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) &&   \
 		(addr[3] == 0x00) && (addr[4] == 0x00) && (addr[5] == 0x00));
 }
+*/
 #endif /* PLATFORM_FREEBSD */
 
 #define CFG_IEEE80211_RESERVE_FCS (1<<0)
Index: linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/os_dep/osdep_service.c
===================================================================
--- linux.orig/drivers/net/wireless/rockchip_wlan/rtl8188fu/os_dep/osdep_service.c
+++ linux/drivers/net/wireless/rockchip_wlan/rtl8188fu/os_dep/osdep_service.c
@@ -2356,7 +2356,7 @@ int rtw_readable_file_sz_chk(const char
 
 	if (fsz > sz)
 		return _FALSE;
-	
+
 	return _TRUE;
 }
 
@@ -2837,7 +2837,7 @@ int map_readN(const struct map_t *map, u
 			else
 				c_len = seg->sa + seg->len - offset;
 		}
-			
+
 		_rtw_memcpy(c_dst, c_src, c_len);
 	}
 
@@ -3018,7 +3018,7 @@ void dump_blacklist(void *sel, _queue *b
 	if (rtw_end_of_queue_search(head, list) == _FALSE) {
 		if (title)
 			RTW_PRINT_SEL(sel, "%s:\n", title);
-	
+
 		while (rtw_end_of_queue_search(head, list) == _FALSE) {
 			ent = LIST_CONTAINOR(list, struct blacklist_ent, list);
 			list = get_next(list);
@@ -3163,3 +3163,4 @@ int hexstr2bin(const char *hex, u8 *buf,
 	return 0;
 }
 
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
